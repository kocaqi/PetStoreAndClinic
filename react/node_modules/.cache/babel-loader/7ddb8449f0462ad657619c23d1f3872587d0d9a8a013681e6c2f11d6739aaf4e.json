{"ast":null,"code":"import * as cookie from 'cookie';\nexport function hasDocumentCookie() {\n  // Can we get/set cookies on document.cookie?\n  return typeof document === 'object' && typeof document.cookie === 'string';\n}\nexport function cleanCookies() {\n  document.cookie.split(';').forEach(function (c) {\n    document.cookie = c.replace(/^ +/, '').replace(/=.*/, '=;expires=' + new Date().toUTCString() + ';path=/');\n  });\n}\nexport function parseCookies(cookies, options) {\n  if (typeof cookies === 'string') {\n    return cookie.parse(cookies, options);\n  } else if (typeof cookies === 'object' && cookies !== null) {\n    return cookies;\n  } else {\n    return {};\n  }\n}\nexport function isParsingCookie(value, doNotParse) {\n  if (typeof doNotParse === 'undefined') {\n    // We guess if the cookie start with { or [, it has been serialized\n    doNotParse = !value || value[0] !== '{' && value[0] !== '[' && value[0] !== '\"';\n  }\n  return !doNotParse;\n}\nexport function readCookie(value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var cleanValue = cleanupCookieValue(value);\n  if (isParsingCookie(cleanValue, options.doNotParse)) {\n    try {\n      return JSON.parse(cleanValue);\n    } catch (e) {\n      // At least we tried\n    }\n  }\n  // Ignore clean value if we failed the deserialization\n  // It is not relevant anymore to trim those values\n  return value;\n}\nfunction cleanupCookieValue(value) {\n  // express prepend j: before serializing a cookie\n  if (value && value[0] === 'j' && value[1] === ':') {\n    return value.substr(2);\n  }\n  return value;\n}","map":{"version":3,"names":["cookie","hasDocumentCookie","document","cleanCookies","split","forEach","c","replace","Date","toUTCString","parseCookies","cookies","options","parse","isParsingCookie","value","doNotParse","readCookie","cleanValue","cleanupCookieValue","JSON","e","substr"],"sources":["/home/albi/Desktop/gitrep/PetStoreAndClinic/react/node_modules/universal-cookie/es6/utils.js"],"sourcesContent":["import * as cookie from 'cookie';\nexport function hasDocumentCookie() {\n    // Can we get/set cookies on document.cookie?\n    return typeof document === 'object' && typeof document.cookie === 'string';\n}\nexport function cleanCookies() {\n    document.cookie.split(';').forEach(function (c) {\n        document.cookie = c\n            .replace(/^ +/, '')\n            .replace(/=.*/, '=;expires=' + new Date().toUTCString() + ';path=/');\n    });\n}\nexport function parseCookies(cookies, options) {\n    if (typeof cookies === 'string') {\n        return cookie.parse(cookies, options);\n    }\n    else if (typeof cookies === 'object' && cookies !== null) {\n        return cookies;\n    }\n    else {\n        return {};\n    }\n}\nexport function isParsingCookie(value, doNotParse) {\n    if (typeof doNotParse === 'undefined') {\n        // We guess if the cookie start with { or [, it has been serialized\n        doNotParse =\n            !value || (value[0] !== '{' && value[0] !== '[' && value[0] !== '\"');\n    }\n    return !doNotParse;\n}\nexport function readCookie(value, options) {\n    if (options === void 0) { options = {}; }\n    var cleanValue = cleanupCookieValue(value);\n    if (isParsingCookie(cleanValue, options.doNotParse)) {\n        try {\n            return JSON.parse(cleanValue);\n        }\n        catch (e) {\n            // At least we tried\n        }\n    }\n    // Ignore clean value if we failed the deserialization\n    // It is not relevant anymore to trim those values\n    return value;\n}\nfunction cleanupCookieValue(value) {\n    // express prepend j: before serializing a cookie\n    if (value && value[0] === 'j' && value[1] === ':') {\n        return value.substr(2);\n    }\n    return value;\n}\n"],"mappings":"AAAA,OAAO,KAAKA,MAAM,MAAM,QAAQ;AAChC,OAAO,SAASC,iBAAiBA,CAAA,EAAG;EAChC;EACA,OAAO,OAAOC,QAAQ,KAAK,QAAQ,IAAI,OAAOA,QAAQ,CAACF,MAAM,KAAK,QAAQ;AAC9E;AACA,OAAO,SAASG,YAAYA,CAAA,EAAG;EAC3BD,QAAQ,CAACF,MAAM,CAACI,KAAK,CAAC,GAAG,CAAC,CAACC,OAAO,CAAC,UAAUC,CAAC,EAAE;IAC5CJ,QAAQ,CAACF,MAAM,GAAGM,CAAC,CACdC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAClBA,OAAO,CAAC,KAAK,EAAE,YAAY,GAAG,IAAIC,IAAI,EAAE,CAACC,WAAW,EAAE,GAAG,SAAS,CAAC;EAC5E,CAAC,CAAC;AACN;AACA,OAAO,SAASC,YAAYA,CAACC,OAAO,EAAEC,OAAO,EAAE;EAC3C,IAAI,OAAOD,OAAO,KAAK,QAAQ,EAAE;IAC7B,OAAOX,MAAM,CAACa,KAAK,CAACF,OAAO,EAAEC,OAAO,CAAC;EACzC,CAAC,MACI,IAAI,OAAOD,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EAAE;IACtD,OAAOA,OAAO;EAClB,CAAC,MACI;IACD,OAAO,CAAC,CAAC;EACb;AACJ;AACA,OAAO,SAASG,eAAeA,CAACC,KAAK,EAAEC,UAAU,EAAE;EAC/C,IAAI,OAAOA,UAAU,KAAK,WAAW,EAAE;IACnC;IACAA,UAAU,GACN,CAACD,KAAK,IAAKA,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,GAAI;EAC5E;EACA,OAAO,CAACC,UAAU;AACtB;AACA,OAAO,SAASC,UAAUA,CAACF,KAAK,EAAEH,OAAO,EAAE;EACvC,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC,IAAIM,UAAU,GAAGC,kBAAkB,CAACJ,KAAK,CAAC;EAC1C,IAAID,eAAe,CAACI,UAAU,EAAEN,OAAO,CAACI,UAAU,CAAC,EAAE;IACjD,IAAI;MACA,OAAOI,IAAI,CAACP,KAAK,CAACK,UAAU,CAAC;IACjC,CAAC,CACD,OAAOG,CAAC,EAAE;MACN;IAAA;EAER;EACA;EACA;EACA,OAAON,KAAK;AAChB;AACA,SAASI,kBAAkBA,CAACJ,KAAK,EAAE;EAC/B;EACA,IAAIA,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;IAC/C,OAAOA,KAAK,CAACO,MAAM,CAAC,CAAC,CAAC;EAC1B;EACA,OAAOP,KAAK;AAChB"},"metadata":{},"sourceType":"module","externalDependencies":[]}