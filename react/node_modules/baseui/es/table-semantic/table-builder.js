function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*
Copyright (c) Uber Technologies, Inc.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
*/
import * as React from 'react';
import { StyledRoot, StyledTable, StyledTableHead, StyledTableHeadRow, StyledTableHeadCell, StyledTableHeadCellSortable, StyledTableBody, StyledTableBodyRow, StyledTableBodyCell, StyledTableLoadingMessage, StyledTableEmptyMessage, StyledSortIconContainer } from './styled-components';
import { getOverrides } from '../helpers/overrides';
import Blank from '../icon/blank';
import ChevronDown from '../icon/chevron-down';
import ChevronUp from '../icon/chevron-up';
import { isFocusVisible, forkFocus, forkBlur } from '../utils/focusVisible';
export default class TableBuilder extends React.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      isFocusVisible: false
    });

    _defineProperty(this, "handleFocus", event => {
      if (isFocusVisible(event)) {
        this.setState({
          isFocusVisible: true
        });
      }
    });

    _defineProperty(this, "handleBlur", event => {
      if (this.state.isFocusVisible !== false) {
        this.setState({
          isFocusVisible: false
        });
      }
    });
  }

  render() {
    const {
      overrides = {},
      children,
      data,
      divider,
      horizontalScrollWidth,
      sortColumn,
      sortOrder = 'ASC',
      onSort,
      isLoading,
      loadingMessage,
      emptyMessage,
      size,
      ...rest
    } = this.props;
    const [Root, rootProps] = getOverrides(overrides.Root, StyledRoot);
    const [Table, tableProps] = getOverrides(overrides.Table, StyledTable);
    const [TableHead, tableHeadProps] = getOverrides(overrides.TableHead, StyledTableHead);
    const [TableHeadRow, tableHeadRowProps] = getOverrides(overrides.TableHeadRow, StyledTableHeadRow);
    const [TableHeadCell, tableHeadCellProps] = getOverrides(overrides.TableHeadCell, StyledTableHeadCell);
    const [TableHeadCellSortable, tableHeadCellSortableProps] = getOverrides(overrides.TableHeadCellSortable, StyledTableHeadCellSortable);
    const [TableBody, tableBodyProps] = getOverrides(overrides.TableBody, StyledTableBody);
    const [TableBodyRow, tableBodyRowProps] = getOverrides(overrides.TableBodyRow, StyledTableBodyRow);
    const [TableBodyCell, tableBodyCellProps] = getOverrides(overrides.TableBodyCell, StyledTableBodyCell);
    const [TableLoadingMessage, tableLoadingMessageProps] = getOverrides(overrides.TableLoadingMessage, StyledTableLoadingMessage);
    const [TableEmptyMessage, tableEmptyMessageProps] = getOverrides(overrides.TableEmptyMessage, StyledTableEmptyMessage);
    const [SortIconContainer, sortIconContainerProps] = getOverrides(overrides.SortIconContainer, StyledSortIconContainer);
    const [SortAscIcon, sortAscIconProps] = getOverrides(overrides.SortAscIcon, ChevronUp);
    const [SortDescIcon, sortDescIconProps] = getOverrides(overrides.SortDescIcon, ChevronDown);
    const [SortNoneIcon, sortNoneIconProps] = getOverrides(overrides.SortNoneIcon, Blank);
    const columns = React.Children.toArray(children).filter(Boolean) // @ts-expect-error todo(flow->ts): limit children to be only react elements
    .map(child => child.props);

    function renderHeader(col, colIndex, isFocusVisible) {
      const colOverrides = col.overrides || {};

      if (!col.sortable) {
        const [ColTableHeadCell, colTableHeadCellProps] = getOverrides(colOverrides.TableHeadCell, TableHeadCell);
        return /*#__PURE__*/React.createElement(ColTableHeadCell, _extends({
          key: colIndex,
          $col: col,
          $colIndex: colIndex,
          $divider: divider,
          $isNumeric: col.numeric,
          $size: size
        }, tableHeadCellProps, colTableHeadCellProps), col.header);
      }

      const [ColTableHeadCellSortable, colTableHeadCellSortableProps] = getOverrides(colOverrides.TableHeadCellSortable, TableHeadCellSortable);
      let sortIcon = null;
      let sortLabel = 'not sorted';

      switch (col.id === sortColumn && sortOrder) {
        case 'ASC':
          sortIcon = /*#__PURE__*/React.createElement(SortAscIcon, _extends({
            size: "16px",
            "aria-hidden": true,
            role: "presentation"
          }, sortAscIconProps));
          sortLabel = 'ascending sorting';
          break;

        case 'DESC':
          sortIcon = /*#__PURE__*/React.createElement(SortDescIcon, _extends({
            size: "16px",
            "aria-hidden": true,
            role: "presentation"
          }, sortDescIconProps));
          sortLabel = 'descending sorting';
          break;

        default:
          sortIcon = /*#__PURE__*/React.createElement(SortNoneIcon, _extends({
            size: "16px",
            "aria-hidden": true,
            role: "presentation"
          }, sortNoneIconProps));
          break;
      }

      return /*#__PURE__*/React.createElement(ColTableHeadCellSortable, _extends({
        key: colIndex,
        $col: col,
        $colIndex: colIndex,
        $divider: divider,
        $isNumeric: col.numeric,
        role: "button",
        tabIndex: "0",
        "aria-label": `${col.tableHeadAriaLabel || col.header}, ${sortLabel}`,
        $isFocusVisible: isFocusVisible,
        onClick: () => onSort && onSort(col.id),
        onKeyDown: e => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            onSort && onSort(col.id);
          }
        }
      }, tableHeadCellSortableProps, colTableHeadCellSortableProps), col.header, /*#__PURE__*/React.createElement(SortIconContainer, sortIconContainerProps, sortIcon));
    }

    function renderCell(col, colIndex, row, rowIndex, lastRowindex) {
      const colOverrides = col.overrides || {};
      const [ColTableBodyCell, colTableBodyCellProps] = getOverrides(colOverrides.TableBodyCell, TableBodyCell);
      return /*#__PURE__*/React.createElement(ColTableBodyCell, _extends({
        key: colIndex,
        $col: col,
        $colIndex: colIndex,
        $divider: divider,
        $row: row,
        $rowIndex: rowIndex,
        $isNumeric: col.numeric,
        $isLastRow: rowIndex === lastRowindex,
        $isSortable: col.sortable,
        $size: size
      }, tableBodyCellProps, colTableBodyCellProps), col.children(row, rowIndex));
    }

    const isEmpty = !isLoading && data.length === 0;
    const isRendered = !isLoading && !isEmpty;
    return /*#__PURE__*/React.createElement(Root, _extends({
      "data-baseweb": "table-builder-semantic",
      $divider: divider
    }, rootProps, rest), /*#__PURE__*/React.createElement(Table, _extends({
      $width: horizontalScrollWidth
    }, tableProps, {
      onBlur: forkBlur(tableProps, this.handleBlur),
      onFocus: forkFocus(tableProps, this.handleFocus)
    }), /*#__PURE__*/React.createElement(TableHead, tableHeadProps, /*#__PURE__*/React.createElement(TableHeadRow, tableHeadRowProps, columns.map((col, colIndex) => renderHeader(col, colIndex, this.state.isFocusVisible)))), /*#__PURE__*/React.createElement(TableBody, tableBodyProps, isLoading && /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("td", {
      colSpan: columns.length
    }, /*#__PURE__*/React.createElement(TableLoadingMessage, tableLoadingMessageProps, typeof loadingMessage === 'function' ? loadingMessage() : loadingMessage))), isEmpty && emptyMessage && /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("td", {
      colSpan: columns.length
    }, /*#__PURE__*/React.createElement(TableEmptyMessage, tableEmptyMessageProps, typeof emptyMessage === 'function' ? emptyMessage() : emptyMessage))), isRendered && data.map((row, rowIndex) => /*#__PURE__*/React.createElement(TableBodyRow, _extends({
      key: rowIndex,
      $divider: divider,
      $row: row,
      $rowIndex: rowIndex
    }, tableBodyRowProps), columns.map((col, colIndex) => renderCell(col, colIndex, row, rowIndex, data.length - 1)))))));
  }

}

_defineProperty(TableBuilder, "defaultProps", {
  data: [],
  loadingMessage: 'Loading...'
});